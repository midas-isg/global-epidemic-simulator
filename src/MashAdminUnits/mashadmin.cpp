/* mashadmin.cpp, part of the Global Epidemic Simulation v1.0 BETA
/* Mash admin unit into synthetic population files.
/*
/* Copyright 2012, MRC Centre for Outbreak Analysis and Modelling
/* 
/* Licensed under the Apache License, Version 2.0 (the "License");
/* you may not use this file except in compliance with the License.
/* You may obtain a copy of the License at
/*
/*       http://www.apache.org/licenses/LICENSE-2.0
/*
/* Unless required by applicable law or agreed to in writing, software
/* distributed under the License is distributed on an "AS IS" BASIS,
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/* See the License for the specific language governing permissions and
/* limitations under the License.
*/


// Mash Admin Units
//
// A helper app for preparing data files for the Global Epidemic Simulation.
//
// Takes one argument: a script.txt file, which lists:-
//
// (1) Path for an INPUT FILE : the map. a 43200x20880 grid of integers, giving the admin unit number for each 
//     co-ordinate. (ie, 1/120 degree in each direction, starting at 180 degrees WEST, 90 degrees NORTH)
// (2) Path for an OUTPUT FILE : the overlay, a 2160x1044 grid of TWO integers (number of houses,
//     number of people). 1/6 degree - ie, local patch size.
// (3)-(7)  - a household, and four place files for INPUT - as generated by the SynthPopul tool.
// (8)-(12) - a household, and four place files for OUTPUT - with the admin unit codes inserted.
//      Then repeat from step (3) for each country.
//
//  The memory usage of this tool will be quite high - about 30-40 gigabytes for runs including China.
//  Hence our examples will launch this on a cluster node.
//
//  Compile with g++ -fopenmp -o mashadmin mashadmin.cpp
//

#ifdef _WIN32
  #include "windows.h"
  #include "io.h"
  #define MM_INT64 __int64
  #ifdef __GNUC__
    #define SEEK fseeko64
    #define TELL ftello64
  #else
    #define SEEK _fseeki64
    #define TELL _ftelli64
  #endif
#else
  #include <stdint.h>
  #define SEEK fseeko64
  #define TELL ftello64
  #define MM_INT64 int64_t
#endif



#include "omp.h"
#include "stdio.h"
#include <vector>
#include <iostream>
#include <fstream>
#include "time.h"


#define MAP_SIZE 902016000
#define ROWS 20880
#define COLS 43200
#define CHUNK 1000000000
#define SMALL_ROWS 1080
#define SMALL_COLS 2160



static int*** overlay_houses;
static int*** overlay_people;
static std::vector<int> map;
static std::vector<unsigned char> buf;
MM_INT64 buf_size;
MM_INT64 buf_capacity;
static unsigned int*** group_info;
static unsigned int no_places[4];
int no_threads;

char* readLine(FILE* file) {
  std::vector<char> s;
  char* result;
  int done=0;
  while (done==0) {
    char ch = fgetc(file);
    if (ch==-1) {
      result=NULL;
      done=1;
    } else if (ch=='\n') {
      result = new char[s.size()+1];
      for (unsigned int i=0; i<s.size(); i++) {
        result[i]=s.at(i);
      }
      result[s.size()]='\0';
      done=1;
    } else s.push_back(ch);
  } 
  return result;
}
  



int getUnitCode(int x, int y) {
  MM_INT64 seek_point = (y*COLS)+(x);
  int code = map.at(seek_point);

  int pass=0;
  int best_candidate_code=-1;
  if (code==-1) {
    long top_boundary=y;
    long bottom_boundary=y;
    long left_boundary=x;
    long right_boundary=x;
    int direction=0; // Left,Up,Right,Down
    char done=0;
      
    while (done==0) {
      if (direction==0) x--;
      else if (direction==1) y--;
      else if (direction==2) x++;
      else if (direction==3) y++;
      seek_point=(COLS*y)+(x);
      code=map.at(seek_point);
      if (code!=-1) {
        best_candidate_code=code;
        done=1;
      } else {
      
        if (direction==0) {
          if ((x<left_boundary) || (x==0)) {
            left_boundary=x;
            direction++;
          }
        } else if (direction==1) {
          if ((y<top_boundary) || (y==0)) {
            top_boundary=y;
            direction++;
          }
        } else if (direction==2) {
          if ((x>right_boundary) || (x==43199)) {  
            right_boundary=x; 
            direction++;
          }
        } else if (direction==3) {
          if ((y>bottom_boundary) || (y==20879)) {
            bottom_boundary=y;
            direction=0;
            pass++;
            if (pass==15) done=1;
          }
        }
      }
    }
  } else best_candidate_code=code;
 
  if (best_candidate_code==-1) {
    best_candidate_code=0;
  }
  return best_candidate_code;
}

void loadBuf(char* in_file) {

  FILE* f_in = fopen(&in_file[0],"rb");
  SEEK(f_in,0L,SEEK_END);
  MM_INT64 size = TELL(f_in);
  if (buf_capacity<size) {
    buf.clear();
    buf.resize(size);
    buf_capacity=size;
  }
  SEEK(f_in,0L,SEEK_SET);

  // Read file
  
  buf_size=size;
  MM_INT64 fp=0;
  MM_INT64 size_read=0;
  while (size>0) {
    if (size>CHUNK) {
      size_read=fread(&buf[fp],1,CHUNK,f_in);
      size-=size_read;
      fp+=size_read;
    } else {
      size_read=fread(&buf[fp],1,size,f_in);
      size-=size_read;
    }
  }
  fclose(f_in);   
}

void saveBuf(char* out_file) {
  FILE* f_out = fopen(&out_file[0],"wb");
  MM_INT64 fp=0;
  MM_INT64 size=buf_size;
  while (size>0) {
    if (size>CHUNK) {
      MM_INT64 zz = fwrite(&buf[fp],1,CHUNK,f_out);
      size-=zz;
      fp+=zz;
    } else {
      MM_INT64 zz = fwrite(&buf[fp],1,size,f_out);
      size-=zz;
      fp+=zz;
    }
  }
  fflush(f_out);
  fclose(f_out);   
  buf_size=0; 
}

void loadMap(char* file) {
  map.resize(MAP_SIZE);
  FILE* f = fopen(&file[0],"rb");
  fread(&map[0],4,MAP_SIZE,f);
  fclose(f);
}

short getShort(MM_INT64 offset) {
  short s=*((short*) &buf[offset]);
  return s;
}

int getInt(MM_INT64 offset) {
  int i=*((int*) &buf[offset]);
  return i;
}

double getDouble(MM_INT64 offset) {
  double d=*((double*) &buf[offset]);
  return d;
}

void setInt(MM_INT64 offset, unsigned int i) {
  for (int j=0; j<4; j++) 
    ((unsigned char*)(&buf[0]))[offset+j]=(unsigned char) (((unsigned char*)&i)[j]);
}

MM_INT64 skipHouse(MM_INT64 offset, int skip_no) {
  if (offset<buf_size) {
    for (int i=0; i<skip_no; i++) {
      offset+=16;
      if (offset<buf_size) {
        short hosts_in_hh = getShort(offset);
        offset+=6+(hosts_in_hh*13);
      }
    }
  }
  return offset;
}

MM_INT64 processHouse(MM_INT64 offset, int thread_no) {
  double lat=getDouble(offset);
  offset+=8;
  double lon=getDouble(offset);
  offset+=8;
  short hosts_in_hh=getShort(offset);
  offset+=2;
  int x = (int) ((lon+180.0)*120.0);
  int y = (int) ((90.0-lat)*120.0);
  setInt(offset,getUnitCode(x,y));
  offset+=4;
  x/=20;
  y/=20;
  overlay_houses[x][y][thread_no]++;
  overlay_people[x][y][thread_no]+=hosts_in_hh;

  for (int j=0; j<hosts_in_hh; j++) {
    offset+=5;  // Skip byte age and float age
    short place_type=getShort(offset);
    offset+=2;
    unsigned int place_no=getInt(offset);
    offset+=4;
    unsigned short group_no=getShort(offset);
    offset+=2;
    if ((place_type>=0) && (place_type<=3)) {
      if (place_no<no_places[place_type]) {
        if (group_no<65535) {
          if (group_no>group_info[place_type][place_no][thread_no]) {
            group_info[place_type][place_no][thread_no]=group_no;
          }
        }
      }
    }
  }
  return offset;
}

void processHH(char* in_file, char* out_file) {
  loadBuf(in_file);

  // Process file.

  // 1. Do the one-off header stuff
  
  short no_age_groups=getShort(0);
  int no_households=getInt(2+(4*no_age_groups));
  int thread=0;
  // 2. The main loop...
#pragma omp parallel for private(thread) schedule(static,1)
  for (thread=0; thread<no_threads; thread++) {
    // Get first iteration point sorted out.
    int house_no=thread;
    MM_INT64 offset=10+(no_age_groups*4);
    
    if (house_no>0) {
      offset=skipHouse(offset,house_no);
    }

    while (house_no<no_households) {
      offset=processHouse(offset,thread);
      offset=skipHouse(offset,no_threads-1);
      house_no+=no_threads;
    }
  }

  // 3. Write array contents back to file

  saveBuf(out_file);
  
}

void writeOverlay(char* overlay_file) {
  FILE* f_out = fopen(&overlay_file[0],"wb");
  for (int i=0; i<SMALL_COLS; i++) {
    for (int j=0; j<SMALL_ROWS; j++) {
      for (int k=1; k<no_threads; k++) {
        overlay_houses[i][j][0]+=overlay_houses[i][j][k];
        overlay_people[i][j][0]+=overlay_people[i][j][k];
      }

      fwrite(&overlay_houses[i][j][0],4,1,f_out);
      fwrite(&overlay_people[i][j][0],4,1,f_out);
    }
  }  
  fclose(f_out);
}

int getNoPlaces(char* file) {
  FILE* f = fopen(&file[0],"rb");
  int no_places;
  short id;
  fread(&id,2,1,f);
  fread(&no_places,4,1,f);
  fclose(f);
  return no_places;
}


void processEst(char* in_file, char* out_file,int place_type) {
  FILE* f_in = fopen(&in_file[0],"rb");
  FILE* f_out = fopen(&out_file[0],"wb");
  short id;
  int no_places;
  double lon,lat;
  int x,y;
  int no_staff,no_hosts;
  int dummy4;
  int unitcode;
  
  fread(&id,2,1,f_in);
  fwrite(&id,2,1,f_out);
  fread(&no_places,4,1,f_in);
  fwrite(&no_places,4,1,f_out);
  for (int i=0; i<no_places; i++) {
    fread(&lat,8,1,f_in);
    fwrite(&lat,8,1,f_out);
    fread(&lon,8,1,f_in);
    fwrite(&lon,8,1,f_out);
    fread(&dummy4,4,1,f_in);   // ignore lsx
    fread(&dummy4,4,1,f_in);   // ignore lsy
    fread(&no_staff,4,1,f_in);
    fread(&no_hosts,4,1,f_in);
    no_staff+=no_hosts;
    fwrite(&no_staff,4,1,f_out);
    fwrite(&group_info[place_type][i][0],4,1,f_out);
    x = (int) ((lon+180.0)*120.0);
    y = (int) ((90.0-lat)*120.0);
    unitcode=getUnitCode(x,y);
    fread(&dummy4,4,1,f_in);   // dummy for unit code.
    fwrite(&unitcode,4,1,f_out);
  }
  fclose(f_out);
  fclose(f_in);
}


int main(int argc, char* argv[])  {
  
  if (argc!=2) {
    printf("MASHADMIN v1. An internal utility for the Global Epidemic Simulator.\n");
    printf("              Usually the script will be system-generated:\n  Usage: mash script.txt\n");
    printf("     Where script contains one entry per line for:\n");
    printf("         (1) - the map file\n");
    printf("         (2) - Output overlay file\n");
    printf("     (3)-(7) - household and four place files for input\n");
    printf("     (8)-(12) -household and four place files for output\n");
    printf("               and repeat from (3) as required\n");
    printf("               Last character: new line, with no more spaces\n");
  } else {
    buf_size=0;
    buf_capacity=0;
    int t = time(NULL);
    printf("MASH v1. Threads ");
    unsigned short place_types=4;
    no_threads=omp_get_max_threads();
    omp_set_num_threads(no_threads);
    int thread=0;
#pragma omp parallel for private(thread) schedule(static,1)
    for (thread=0; thread<no_threads; thread++) {
      printf("%d",thread);
    }
    printf("\n");
  
    FILE* script = fopen(argv[1],"r");
    char* map_file = readLine(script);
    char* overlay_file = readLine(script);

    t=time(NULL);
    loadMap(map_file);
    t=time(NULL)-t;
    printf("Loaded %s in %d s\n",map_file,t);
    fflush(stdout);
      
    overlay_houses=new int**[SMALL_COLS];
    overlay_people=new int**[SMALL_COLS];
    for (int i=0; i<SMALL_COLS; i++) {
      overlay_houses[i]=new int*[SMALL_ROWS];
      overlay_people[i]=new int*[SMALL_ROWS];
      for (int j=0; j<SMALL_ROWS; j++) {
        overlay_houses[i][j]=new int[no_threads];
        overlay_people[i][j]=new int[no_threads];
      }
    }
    for (int i=0; i<SMALL_COLS; i++) {
      for (int j=0; j<SMALL_ROWS; j++) {
        for (int k=0; k<no_threads; k++) {
          overlay_houses[i][j][k]=0;
          overlay_people[i][j][k]=0;
        }
      }
    } 

    while (!feof(script)) {
      char* hh_file_in = readLine(script);
      char* e0_file_in = readLine(script);
      char* e1_file_in = readLine(script);
      char* e2_file_in = readLine(script);
      char* e3_file_in = readLine(script);
      char* hh_file_out = readLine(script);
      char* e0_file_out = readLine(script);
      char* e1_file_out = readLine(script);
      char* e2_file_out = readLine(script);
      char* e3_file_out = readLine(script);
      if (e3_file_out!=NULL) {
        no_places[0]=getNoPlaces(e0_file_in);
        no_places[1]=getNoPlaces(e1_file_in);
        no_places[2]=getNoPlaces(e2_file_in);
        no_places[3]=getNoPlaces(e3_file_in);

        group_info = new unsigned int**[place_types];
        for (unsigned int i=0; i<place_types; i++) {
          group_info[i]=new unsigned int*[no_places[i]];
          for (unsigned int j=0; j<no_places[i]; j++) {
            group_info[i][j]=new unsigned int[no_threads];
            for (int k=0; k<no_threads; k++) {
              group_info[i][j][k]=0;
            }
          }
        }
  
       
     
        t=time(NULL);
        processHH(hh_file_in,hh_file_out);
        t=time(NULL)-t;
        printf("Processed %s -> %s in %d s\n",hh_file_in,hh_file_out,t);
        fflush(stdout);
  
        for (unsigned short i=0; i<place_types; i++) {
          for (unsigned int j=0; j<no_places[i]; j++) {
            for (int k=1; k<no_threads; k++) {
              if (group_info[i][j][k]>group_info[i][j][0]) group_info[i][j][0]=group_info[i][j][k];
            }
          }
        }

        t=time(NULL);  
        processEst(e0_file_in,e0_file_out,0);
        t=time(NULL)-t;
        printf("Processed %s -> %s in %d s\n",e0_file_in,e0_file_out,t);
        fflush(stdout);
    
        t=time(NULL);
        processEst(e1_file_in,e1_file_out,1);
        t=time(NULL)-t;
        printf("Processed %s -> %s in %d s\n",e1_file_in,e1_file_out,t);
        fflush(stdout);
  
        t=time(NULL);
        processEst(e2_file_in,e2_file_out,2);
        t=time(NULL)-t;
        printf("Processed %s -> %s in %d s\n",e2_file_in,e2_file_out,t);
        fflush(stdout);
  
        t=time(NULL);
        processEst(e3_file_in,e3_file_out,3);
        t=time(NULL)-t;
        printf("Processed %s -> %s in %d s\n",e3_file_in,e3_file_out,t);
        fflush(stdout);

        for (unsigned int i=0; i<place_types; i++) {
          for (unsigned int j=0; j<no_places[i]; j++) {
            delete[] group_info[i][j];
          }
          delete[] group_info[i];
        }
        delete[] group_info;
        
      }
    }
    fclose(script);
    writeOverlay(overlay_file);
  }
  return 0;
}